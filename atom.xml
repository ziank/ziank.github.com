<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Ziank的技术分享]]></title>
  <subtitle><![CDATA[一些个人学习的文档]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.ziank.cn/"/>
  <updated>2015-11-19T07:09:37.899Z</updated>
  <id>http://www.ziank.cn/</id>
  
  <author>
    <name><![CDATA[ziank]]></name>
    <email><![CDATA[zhaixianqi0111@163.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[有关web微信的一些处理]]></title>
    <link href="http://www.ziank.cn/2015/11/19/weixin/"/>
    <id>http://www.ziank.cn/2015/11/19/weixin/</id>
    <published>2015-11-19T05:50:47.000Z</published>
    <updated>2015-11-19T07:09:23.000Z</updated>
    <content type="html"><![CDATA[<p>最近由于某些原因吧，想要找一些关于微信发送消息的协议，最后也没有真正的找到，又懒得自己去抓包进行解析，就查找了一些通过http进行微信通信的文章，这里也对自己了解的做一个简单总结。<br><a id="more"></a><br>web微信的通信过程主要就那么几步，登陆，同步，发送消息等等。因为我只看了发送消息的部分，这里也就只简单说一下发送的方法，不多描述接收消息的想法。如果有人想要了解接收的话，可以查看<a href="http://www.myhack58.com/Article/54/93/2015/66422.htm" target="_blank" rel="external">挖掘微信Web网页版通信的全过程</a>，配合自己进行http抓包可以简单的通过分析进行实现。</p>
<ol>
<li>获取二维码。<br> 大家都知道web微信登录主要是通过手机扫描二维码实现，所以第一步就是获取对应的二维码。<ul>
<li>请求uuid，URL地址可以使用<code>https://login.weixin.qq.com/jslogin?appid=wx782c26e4c19acffb&amp;redirect_uri=https%%3A%%2F%%2Fwx.qq.com%%2Fcgi-bin%%2Fmmwebwx-bin%%2Fwebwxnewloginpage&amp;fun=new&amp;lang=zh_CN&amp;_={now_time}</code>，<code>{now_time}</code>为当前时间。返回的结果格式应为<code>window.QRLogin.code = 200; window.QRLogin.uuid = &quot;QaH7gdt7Jg==&quot;</code>;其中uuid就是<code>QaH7gdt7Jg==</code></li>
<li>根据uuid请求登录二维码，URL地址为<code>https://login.weixin.qq.com/qrcode/{uuid}?t=webwx</code>，返回的结果就是二维码图片的二进制流。</li>
</ul>
</li>
<li>扫描二维码。<br> 这里的扫描二维码不是说手机的扫描，而是获取手机的扫描结果过程。这个过程只需要轮询一个URL地址，微信服务器会根据当前扫描状态的不同返回不同的响应结果。这个URL地址为<code>https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid={uuid}&amp;tip=1&amp;_={now_time}</code><ul>
<li>如果响应结果返回<code>window.code=201;</code>说明用户已经扫描完成，但是还没有登录；</li>
<li>如果响应结果返回<code>window.redirect_uri={redirect_url}</code>格式，则说明用户已近登录。</li>
</ul>
</li>
<li>获取uin，sid和ticket<ul>
<li>如果只是简单的发送文字消息，ticket是不需要使用的。</li>
<li>这一步主要是访问上一步返回的<code>{redirect_url}</code>，我在实际访问时添加了<code>&amp;fun=new</code>，实际中可根据需要自行判断使用old还是new。在服务器返回的cookie中会包含wxuin，wxsid，webwx_data_ticket等字段，根据需要把这些内容记录下来。</li>
</ul>
</li>
<li>初始化微信信息<br> 所谓的初始化微信信息就是获取一些当前用户的信息，访问的URL地址为<code>https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxinit?r={now_time}</code>。需要注意的是：<ul>
<li>访问该链接需要使用POST，并且在Body中带上以下的JSON信息：<code>{&quot;BaseRequest&quot;:{&quot;Uin&quot;:&quot;2545437902&quot;,&quot;Sid&quot;:&quot;QfLp+Z+FePzvOFoG&quot;,&quot;Skey&quot;:&quot;&quot;,&quot;DeviceID&quot;:&quot;e1615250492&quot;}}</code>。这个JSON串中Uin和Sid分别是上面步骤中获得的那两个Cookie值，DeviceID是一个本地生成的随机字符串（分析了官方的总是e+一串数字，所以我们也保持这样的格式）。</li>
<li>服务器会返回一个很长的JSON串，其中主要包括有BaseResponse（相应返回码等信息），ContactList（常用联系人），SyncKey（用于和服务器同步消息），User（当前用户的信息），SKey（用于后面发送消息认证使用）等内容。</li>
</ul>
</li>
<li>获取通讯录列表<br> 在初始化微信信息时返回的联系人列表并不全，需要用这一步的接口才可以获取全部的联系人列表。接口URL地址为<code>https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact?r={now_time}</code>。这一步也需要使用POST，但是POST内容只需要设置为空JSON（<code>{}</code>）即可。在返回的JSON串中，MemberList中就包含了所有的好友信息。</li>
<li>发送文字信息<br>发送消息主要通过URL地址<code>https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?sid={sid}&amp;r={now_time}</code>。访问该URL采用POST方式，在Body中的JSON串形如以下的格式：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">{</div><div class="line">    <span class="string">"BaseRequest"</span>   : {</div><div class="line">        <span class="string">"DeviceID"</span>  : <span class="string">"{DeviceID}"</span>,</div><div class="line">        <span class="string">"Sid"</span>       : <span class="string">"{sid}"</span>,</div><div class="line">        <span class="string">"Skey"</span>      : <span class="string">"{skey}"</span>,</div><div class="line">        <span class="string">"Uin"</span>       : <span class="string">"{uin}"</span></div><div class="line">    },</div><div class="line">    <span class="string">"Msg"</span>           : {</div><div class="line">        <span class="string">"ClientMsgId"</span>   : {clientMsgId},</div><div class="line">        <span class="string">"Content"</span>       : <span class="string">"{{messageContent}"</span>,</div><div class="line">        <span class="string">"FromUserName"</span>  : <span class="string">"{currentUserName}"</span>,</div><div class="line">        <span class="string">"LocalID"</span>       : {localId},</div><div class="line">        <span class="string">"ToUserName"</span>    : <span class="string">"{toUserName}"</span>,</div><div class="line">        <span class="string">"Type"</span> : <span class="number">1</span></div><div class="line">    },</div><div class="line">    <span class="string">"rr"</span> = {now_time}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中BaseRequest都是授权相关的值，与上面的步骤中的值对应，Msg是对消息的描述，包括了发送人与接收人，消息内容，消息的类型(1为文本)，ClientMsgId和LocalID由本地生成。rr可用当前的时间。<br>    在返回JSON结果中BaseResponse描述了发送情况，Ret为0表示发送成功。</p>
<p>我了解的基本也只有这些了，如果以后有兴趣做新的了解的再继续描述吧。</p>
<p>参考资料：<br><a href="http://www.myhack58.com/Article/54/93/2015/66422.htm" target="_blank" rel="external">《挖掘微信Web网页版通信的全过程》</a><br><a href="http://bbs.125.la/thread-13711355-1-1.html" target="_blank" rel="external">微信Post/Get的封包，论坛还没有发布</a><br><a href="https://github.com/xiangzhai/qwx/blob/master/doc/protocol.md" target="_blank" rel="external">网页微信客户端封包大全</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近由于某些原因吧，想要找一些关于微信发送消息的协议，最后也没有真正的找到，又懒得自己去抓包进行解析，就查找了一些通过http进行微信通信的文章，这里也对自己了解的做一个简单总结。<br>]]>
    
    </summary>
    
      <category term="微信" scheme="http://www.ziank.cn/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="网络" scheme="http://www.ziank.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络" scheme="http://www.ziank.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS应用Push证书的申请]]></title>
    <link href="http://www.ziank.cn/2015/08/14/notification/"/>
    <id>http://www.ziank.cn/2015/08/14/notification/</id>
    <published>2015-08-14T06:29:02.000Z</published>
    <updated>2015-08-14T07:13:30.000Z</updated>
    <content type="html"><![CDATA[<p>我们都知道苹果的iOS应用只支持自己的APNS推送，所有的开发者如果要开发推送功能都必须申请APNS推送证书，才能够实现推送功能。<br>基本上对iOS有点了解的开发者都明白APNS推送的基本原理，那就是客户端向APNS请求deviceToken，传递给Server，然后Server根据这个deviceToken和APNS推送证书，把要推送的消息发送给APNS服务器，APNS服务器就会把对应的消息发送给客户端设备，进而分发给应用。<br><a id="more"></a><br><img src="/img/apns_1.jpg" alt="APNS推送原理"></p>
<h2 id="申请Push证书流程">申请Push证书流程</h2>
<p>那么我们使用服务器向APNS服务发送消息的时候，可以通过客户端获取到DeviceToken，那么推送证书，也就是上图中的payload从哪里获取呢？这个就要去苹果的开发者网站上生成对应的APNS推送证书并下载了。<br>生成APNS推送证书的主要步骤和生成开发者证书类似，都要先生成一个certSigningRequest文件，也就是在【钥匙串】【证书助理】中生成的请求文件，不会的童鞋可以百度一下开发者证书的生成过程。<br>之后在开发者网站上打开要推送应用的AppID，点击Edit，进入下图中的界面。<br><img src="/img/apns_2.png" alt="生成推送证书"><br>勾选Push Notifications，然后选择Create Certificate，分别对应开发环境的push证书，和上线AppStore后的push证书。创建证书的过程和创建开发者证书一样。</p>
<p>下载push证书以后，可以在钥匙串中导出对应的p12证书文件，然后就可以使用该证书连接APNS服务器，发送PUSH消息了。需要注意的是发送的消息必须是指定格式的内容，否则会发送失败哦。<br><img src="/img/apns_3.png" alt="生成p12证书文件"></p>
<h2 id="客户端获取DeviceToken的方法">客户端获取DeviceToken的方法</h2>
<p>客户端需要在didFinishLaunching方法中添加注册push通知的方法，以获取对应的deviceToken。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">{</div><div class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</div><div class="line">[[<span class="built_in">UIApplication</span> sharedApplication] registerForRemoteNotificationTypes: UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert];</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>然后添加接收注册结果的方法，就可以获取到对应的deviceToken。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="pp">- <span class="params">(void)</span>application:<span class="params">(<span class="variable">UIApplication</span> *)</span>application didRegisterForRemoteNotificationsWithDeviceToken:<span class="params">(<span class="variable">NSData</span> *)</span>pToken {</span></div><div class="line">NSLog<span class="params">(@<span class="string">"regisger success:%@"</span>, p<span class="variable">Token</span>)</span>;</div><div class="line">//注册成功，返回deviceToken</div><div class="line">}</div></pre></td></tr></table></figure>

<p>同一个应用在同一台设备上的deviceToken基本上都是不会变化的，一般只有对设备恢复出厂设置才会导致deviceToken的变化。</p>
<h3 id="但是要注意的是，一个应用的develop和distribution版本获取到的deviceToken是不同的。">但是要注意的是，一个应用的develop和distribution版本获取到的deviceToken是不同的。</h3>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们都知道苹果的iOS应用只支持自己的APNS推送，所有的开发者如果要开发推送功能都必须申请APNS推送证书，才能够实现推送功能。<br>基本上对iOS有点了解的开发者都明白APNS推送的基本原理，那就是客户端向APNS请求deviceToken，传递给Server，然后Server根据这个deviceToken和APNS推送证书，把要推送的消息发送给APNS服务器，APNS服务器就会把对应的消息发送给客户端设备，进而分发给应用。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="Push" scheme="http://www.ziank.cn/tags/Push/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TodayExtension的覆盖安装]]></title>
    <link href="http://www.ziank.cn/2015/07/09/todayviewReinstall/"/>
    <id>http://www.ziank.cn/2015/07/09/todayviewReinstall/</id>
    <published>2015-07-09T07:16:37.000Z</published>
    <updated>2015-07-09T07:35:22.000Z</updated>
    <content type="html"><![CDATA[<p>这里有两个问题需要注意一下，一个是覆盖安装或者升级后TodayExtension的内容不会更新；另一个是在覆盖安装后TodayExtension的界面整个冻结，无法点击。<br><a id="more"></a></p>
<p>我们先说第一个问题，这个问题主要出现在使用XCode重复安转应用之后，会发现自己对TodayExtension的修改没有生效，其主要原因是设置的问题，XCode中对于TodayExtension有一项设置是只在安装和更新时copy插件，需要取消选中才能够在使用XCode时对TodayExtension的修改直接生效。<br><img src="/img/copyOnly.png" alt="XCode设置项位置"></p>
<p>再说第二个问题，我在使用fir安装应用的时候遇到了第二个问题，搜索了stackOverFlow，查看了苹果的官方文档，都没有发现解决方案，最后才发现这个问题可以说是庸人自扰。这个问题是由于使用了企业发布的安装方式才导致的。由于使用企业发布，重新安装时不会在原来的应用程序上直接覆盖，而是新安装应用，然后删除原来的应用。这样就导致了原来应用的TodayExtension没有重新刷新，所以会导致界面冻结的情况。实际上只要使用苹果提供的testFlight进行测试就会发现，这个问题在上传到AppStore时并不会存在，不需要进行过多的关心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里有两个问题需要注意一下，一个是覆盖安装或者升级后TodayExtension的内容不会更新；另一个是在覆盖安装后TodayExtension的界面整个冻结，无法点击。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="today" scheme="http://www.ziank.cn/tags/today/"/>
    
      <category term="extension" scheme="http://www.ziank.cn/tags/extension/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅析const char *, char * const, char const *, const char * const 的区别]]></title>
    <link href="http://www.ziank.cn/2015/05/14/char-const/"/>
    <id>http://www.ziank.cn/2015/05/14/char-const/</id>
    <published>2015-05-14T08:14:31.000Z</published>
    <updated>2015-05-14T08:33:02.000Z</updated>
    <content type="html"><![CDATA[<p>不知道别人是什么样，反正我每次看到<code>const char *</code> 和<code>char * const</code> 就想把写这个代码的人给拉出来枪毙十分钟，教科书上说过它们的区别，但是每次都会忘记，所以只能够每次都去网上查找。<br><a id="more"></a><br>这次我也只是相当于做一个记录，让自己和看到这篇博客的人知道可以在这里找到答案。</p>
<ul>
<li><code>const char *p</code> 是一个指向常量的指针，就是说不能能够修改<code>*p</code>的值，但是可以修改<code>p</code>的值</li>
<li><code>char *const p</code> 是一个常量指针，指向的内容是变量，所以<code>p</code>可以修改<code>*p</code>的值，但是不可以修改<code>p</code>的值</li>
<li><code>char const *p</code> 和<code>const char* p</code>是一样的</li>
<li><code>const *char p</code> 会引起编译错误，是一种错误的写法</li>
<li><code>const char * const p</code> 是一个指向常量的常量指针，就是说p和*p都不可以修改</li>
</ul>
<p>或者简单地说，1，2的情况就是<code>const</code>修饰更近的参数，与<code>char</code>相近时修饰<code>char</code>，也就是指针值不可修改；与<code>*</code>相近时修饰地址，也就是指针不可修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>不知道别人是什么样，反正我每次看到<code>const char *</code> 和<code>char * const</code> 就想把写这个代码的人给拉出来枪毙十分钟，教科书上说过它们的区别，但是每次都会忘记，所以只能够每次都去网上查找。<br>]]>
    
    </summary>
    
      <category term="C" scheme="http://www.ziank.cn/tags/C/"/>
    
      <category term="C/C++" scheme="http://www.ziank.cn/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[todayView组件的高度处理问题]]></title>
    <link href="http://www.ziank.cn/2015/05/11/todayViewExtensionHeight/"/>
    <id>http://www.ziank.cn/2015/05/11/todayViewExtensionHeight/</id>
    <published>2015-05-11T07:17:59.000Z</published>
    <updated>2015-05-11T08:51:29.000Z</updated>
    <content type="html"><![CDATA[<p>最近在我们的应用里添加了一个TodayView的组件，结果却发现高度总是设置不正确，或者说是设置好了以后在第一次安装时会出现界面拉伸的问题，后来发现是由于在安装时，底部会自动增加大约40个点的高度，导致界面拉伸或者是位置不正确。<br><a id="more"></a><br><img src="/img/todayViewExtensionHeight_1.png" alt="位置不正确的图片"></p>
<p>为此我们查了不少资料，最后发现只是一个很简单地设置问题，是由于系统默认的todayView的偏移量为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">defaultMarginInsets =</span> (<span class="variable">top =</span> <span class="number">0</span>, <span class="variable">left =</span> <span class="number">47</span>, <span class="variable">bottom =</span> <span class="number">39</span>, <span class="variable">right =</span> <span class="number">0</span>);</div></pre></td></tr></table></figure>

<p>所以只需要简单地修改这个偏移量，就能够解决该问题。对偏移量的修改应该在方法<code>widgetMarginInsetsForProposedMarginInsets</code>中进行修改:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIEdgeInsets</span>)widgetMarginInsetsForProposedMarginInsets:(<span class="built_in">UIEdgeInsets</span>)defaultMarginInsets</div><div class="line">{</div><div class="line">    defaultMarginInsets<span class="variable">.bottom</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> defaultMarginInsets;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>修改之后，todayView的界面就正常了。<br><img src="/img/todayViewExtensionHeight_2.png" alt="修改后的todayViewExtension截图"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在我们的应用里添加了一个TodayView的组件，结果却发现高度总是设置不正确，或者说是设置好了以后在第一次安装时会出现界面拉伸的问题，后来发现是由于在安装时，底部会自动增加大约40个点的高度，导致界面拉伸或者是位置不正确。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift的操作符重载]]></title>
    <link href="http://www.ziank.cn/2015/03/27/swift-operator/"/>
    <id>http://www.ziank.cn/2015/03/27/swift-operator/</id>
    <published>2015-03-27T02:23:38.000Z</published>
    <updated>2015-03-27T03:31:46.000Z</updated>
    <content type="html"><![CDATA[<p>今天简单说一下操作符重载的相关知识吧，希望对自己和别人能够有所帮助。相信懂得C++的同学对于运算符重载并不陌生，在swift中也是支持重载运算符这种特性的。</p>
<p>操作符重载的好处无需多说，相信大家都明白。那么我们在swift应该如何重载操作符呢？其实很简单，和C++基本一样，只需要添加对应的函数实现就可以了。</p>
<a id="more"></a>

<p>例如我们重载加号操作符的话：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> +(<span class="keyword">left</span>:<span class="type">CalcNode</span>, <span class="keyword">right</span>: <span class="type">CalcNode</span>) -&gt; <span class="type">CalcNode</span> {</div><div class="line">    <span class="keyword">return</span> <span class="type">CalcNode</span>(number:<span class="keyword">left</span>.value + <span class="keyword">right</span>.value)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>但是，和C++中得运算符冲在不同的是，如果要使用新增的运算符的话，还需要在函数重载之前对该操作符进行声明。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ** { </div><div class="line">    <span class="keyword">associativity</span> <span class="keyword">left</span> </div><div class="line">    <span class="keyword">precedence</span> <span class="number">160</span> </div><div class="line">}</div><div class="line"><span class="func"><span class="keyword">func</span></span> ** (<span class="keyword">left</span>: <span class="type">Double</span>, <span class="keyword">right</span>: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {</div><div class="line">    <span class="keyword">return</span> pow(<span class="keyword">left</span>, <span class="keyword">right</span>)</div><div class="line">}</div><div class="line"></div><div class="line"><span class="number">2</span> ** <span class="number">3</span> </div><div class="line"><span class="comment">// 8</span></div></pre></td></tr></table></figure>

<p>上述代码就是声明了一个中位操作符+*，后面就可以添加对应的重载函数实现该运算符的具体操作。<br>我们先说一下几个关键字的具体作用吧：</p>
<ul>
<li>infix/prefix/postfix： 分别用来表示中位操作符、前位操作符和后位操作符。其中infix说明操作符前后都是输入。</li>
<li></li>
<li><p>associativity：<br>定义了结合律，即如果多个同类的操作符顺序出现的计算顺序， left，就是说多个操作同时出现时按照从左往右的顺序计算 </p>
</li>
<li><p>precedence：<br>运算的优先级，越高的话越优先进行运算。Swift 中乘法和除法的优先级是 150，加法和减法是 140，这里我们定义乘方的优先级为 160，就是说应该早于普通的乘除进行运算。</p>
</li>
</ul>
<p>其中associativity和precedence都是swift的中位运算符的一些属性修饰。如果是前位/后位运算符的话，则不能够实用这些属性来进行修改。</p>
<p>简单地举个prefix的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> √ {}</div><div class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span></span> √ (number: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {</div><div class="line">    <span class="keyword">return</span> sqrt(number)</div><div class="line">}</div><div class="line"></div><div class="line">√<span class="number">4</span></div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure>

<p>需要注意的是:<h3><strong>运算符重载函数只能够定义在全局作用域。</strong></h3></p>
<p>附&lt; swift中的常用操作符 &gt;：</p>
<h3 id="prefix">Prefix:</h3><br><code>++</code>: Increment<br><code>—</code>: Decrement<br><code>+</code> : Unary plus<br><code>-</code> : Unary minus<br><code>!</code> : Logical NOT<br><code>~</code> : Bitwise NOT<br><br><h3 id="postfix">Postfix:</h3><br><code>++</code>: Increment<br><code>—</code>: Decrement<br><br><h3 id="infix">Infix:</h3>

<table><tr><th colspan="2">Exponentiative <tt>{precedence 160}</tt></th></tr><tbody><tr><td><tt>&lt;&lt;</tt></td><td>Bitwise left shift</td></tr><tr><td><tt>&gt;&gt;</tt></td><td>Bitwise right shift</td></tr></tbody><tr><th colspan="2">Multiplicative <tt>{ associativity left precedence 150 }</tt></th></tr><tbody><tr><td><tt><em></em></tt></td><td>Multiply</td></tr><tr><td><tt>/</tt></td><td>Divide</td></tr><tr><td><tt>%</tt></td><td>Remainder</td></tr><tr><td><tt>&amp;</tt></td><td>Multiply, ignoring overflow</td></tr><tr><td><tt>&amp;/</tt></td><td>Divide, ignoring overflow</td></tr><tr><td><tt>&amp;%</tt></td><td>Remainder, ignoring overflow</td></tr><tr><td><tt>&amp;</tt></td><td>Bitwise AND</td></tr></tbody><tr><th colspan="2">Additive <tt>{ associativity left precedence 140 }</tt></th></tr><tbody><tr><td><tt>+</tt></td><td>Add</td></tr><tr><td><tt>-</tt></td><td>Subtract</td></tr><tr><td><tt>&amp;+</tt></td><td>Add with overflow</td></tr><tr><td><tt>&amp;-</tt></td><td>Subtract with overflow</td></tr><tr><td><tt>|</tt></td><td>Bitwise OR</td></tr><tr><td><tt>^</tt></td><td>Bitwise XOR</td></tr></tbody><tr><th colspan="2">Range <tt>{ precedence 135 }</tt></th></tr><tbody><tr><td><tt>..&lt;</tt></td><td>Half-open range</td></tr><tr><td><tt>…</tt></td><td>Closed range</td></tr></tbody><tr><th colspan="2">Cast <tt>{ precedence 132 }</tt></th></tr><tbody><tr><td><tt>is</tt></td><td>Type check</td></tr><tr><td><tt>as</tt></td><td>Type cast</td></tr></tbody><tr><th colspan="2">Comparative <tt>{ precedence 130 }</tt></th></tr><tbody><tr><td><tt>&lt;</tt></td><td>Less than</td></tr><tr><td><tt>&lt;=</tt></td><td>Less than or equal</td></tr><tr><td><tt>&gt;</tt></td><td>Greater than</td></tr><tr><td><tt>&gt;=</tt></td><td>Greater than or equal</td></tr><tr><td><tt>==</tt></td><td>Equal</td></tr><tr><td><tt>!=</tt></td><td>Not equal</td></tr><tr><td><tt>===</tt></td><td>Identical</td></tr><tr><td><tt>!==</tt></td><td>Not identical</td></tr><tr><td><tt>~=</tt></td><td>Pattern match</td></tr></tbody><tr><th colspan="2">Conjunctive <tt>{ associativity left precedence 120 }</tt></th></tr><tbody><tr><td><tt>&amp;&amp;</tt></td><td>Logical AND</td></tr></tbody><tr><th colspan="2">Disjunctive <tt>{ associativity left precedence 110 }</tt></th></tr><tbody><tr><td><tt>||</tt></td><td>Logical OR</td></tr></tbody><tr><th colspan="2">Nil Coalescing <tt>{ associativity right precedence 110 }</tt></th></tr><tbody><tr><td><tt>??</tt></td><td>Nil coalescing</td></tr></tbody><tr><th colspan="2">Ternary Conditional <tt>{ associativity right precedence 100 }</tt></th></tr><tbody><tr><td><tt>?:</tt></td><td>Ternary conditional</td></tr></tbody><tr><th colspan="2">Assignment <tt>{ associativity right precedence 90 }</tt></th></tr><tbody><tr><td><tt>=</tt></td><td>Assign</td></tr><tr><td><tt>*=</tt></td><td>Multiply and assign</td></tr><tr><td><tt>/=</tt></td><td>Divide and assign</td></tr><tr><td><tt>%=</tt></td><td>Remainder and assign</td></tr><tr><td><tt>+=</tt></td><td>Add and assign</td></tr><tr><td><tt>-=</tt></td><td>Subtract and assign</td></tr><tr><td><tt>&lt;&lt;=</tt></td><td>Left bit shift and assign</td></tr><tr><td><tt>&gt;&gt;=</tt></td><td>Right bit shift and assign</td></tr><tr><td><tt>&amp;=</tt></td><td>Bitwise AND and assign</td></tr><tr><td><tt>^=</tt></td><td>Bitwise XOR and assign</td></tr><tr><td><tt>|=</tt></td><td>Bitwise OR and assign</td></tr><tr><td><tt>&amp;&amp;=</tt></td><td>Logical AND and assign</td></tr><tr><td><tt>||=</tt></td><td>Logical OR and assign</td></tr></tbody></table>]]></content>
    <summary type="html">
    <![CDATA[<p>今天简单说一下操作符重载的相关知识吧，希望对自己和别人能够有所帮助。相信懂得C++的同学对于运算符重载并不陌生，在swift中也是支持重载运算符这种特性的。</p>
<p>操作符重载的好处无需多说，相信大家都明白。那么我们在swift应该如何重载操作符呢？其实很简单，和C++基本一样，只需要添加对应的函数实现就可以了。</p>
]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/tags/swift/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/categories/iOS/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift的一些注意点(2)]]></title>
    <link href="http://www.ziank.cn/2015/03/25/swift-2/"/>
    <id>http://www.ziank.cn/2015/03/25/swift-2/</id>
    <published>2015-03-25T02:23:38.000Z</published>
    <updated>2015-03-25T08:58:59.000Z</updated>
    <content type="html"><![CDATA[<p>之前说了在学习swift过程中发现的一些和其他语言不同的点，最近在使用swift语言进行一个简单计算器的开发工作，在使用中又发现了一些需要注意的地方，这里就简单的说一下。<br><a id="more"></a></p>
<h3 id="6-_switch/case的使用">6. switch/case的使用</h3>
<p>和其他语言一样，swift也支持switch的使用。但是和其他语言不同的是，swift里面的每一个case分支不需要显示break，而是在执行结束后会自动break。<br>而且如果对不同case执行相同操作的话，和其他语言的写法也不相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">init</span>(calc: <span class="type">CalcType</span>) {</div><div class="line">    calcElement = <span class="type">NodeType</span>.<span class="type">Action</span>(calc)</div><div class="line">    <span class="keyword">switch</span> calc {</div><div class="line">    <span class="keyword">case</span> .<span class="type">Add</span>, .<span class="type">Minus</span>, .<span class="type">Mod</span>:</div><div class="line">        calcOrder = <span class="type">CalcOrder</span>.<span class="type">Add</span></div><div class="line">    <span class="keyword">case</span> .<span class="type">Multi</span>, .<span class="type">Divide</span>:</div><div class="line">        calcOrder = <span class="type">CalcOrder</span>.<span class="type">Multi</span></div><div class="line">    <span class="keyword">case</span> .<span class="type">And</span>, .<span class="type">Or</span>, .<span class="type">Xor</span>:</div><div class="line">        calcOrder = <span class="type">CalcOrder</span>.<span class="type">Logic</span></div><div class="line">    <span class="keyword">case</span> .<span class="type">ShiftLeft</span>, .<span class="type">ShiftRight</span>:</div><div class="line">        calcOrder = <span class="type">CalcOrder</span>.<span class="type">Shift</span></div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="7-_成员变量getter/setter方法的定义">7. 成员变量getter/setter方法的定义</h3>
<p>OC中get/set方法的定义一般是通过getter/setter来声明，或者直接修改系统默认的getter/setter方法。而在swift中对属性的getter/setter方法实在定义该属性时直接通过get/set进行设置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> value:<span class="type">UInt</span> {</div><div class="line">    <span class="keyword">get</span> {</div><div class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.calcElement {</div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Number</span>(number):</div><div class="line">            <span class="keyword">return</span> number</div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Action</span>(str):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.calcValue(str)</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">set</span> (newValue) {</div><div class="line">        <span class="keyword">self</span>.value = newValue</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="8-_enum的使用">8. enum的使用</h3>
<p>在OC等语言中，enum就是一个枚举类型，只能够定义一组枚举常量。但是在swift中，enum除了类似功能以外，还可以把不同的数据类型存储在同一个变量中，有点类似于C中union的用法。<br>如可以这样定义enum：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NodeType</span> </span>{</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">UInt</span>)</div><div class="line">    <span class="keyword">case</span> <span class="type">Action</span>(<span class="type">CalcType</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>那么在NodeType类型的变量中就会有一个UInt或者是CalcType类型的变量，可以在适当的时候获取对应的数据。由7的示例代码中可以看到，当需要获取对应数据时，使用case let可以把数据从enum的变量中获取出来。</p>
<p>当然，在enum中也可以直接定义函数，用来对内部的一些数据进行处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CalcOrder</span>:<span class="title">Int</span> </span>{</div><div class="line">    <span class="keyword">case</span> <span class="type">Number</span> = <span class="number">5</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Add</span>    = <span class="number">1</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Multi</span>  = <span class="number">2</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Logic</span>  = <span class="number">3</span></div><div class="line">    <span class="keyword">case</span> <span class="type">Shift</span>  = <span class="number">4</span></div><div class="line">    <span class="func"><span class="keyword">func</span></span> isLargerThan(val:<span class="type">CalcOrder</span>) -&gt; <span class="type">Bool</span> {</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.rawValue &gt; val.rawValue</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="9-_函数外部参数名的使用规则">9. 函数外部参数名的使用规则</h3>
<p>我们前面说过函数外部参数名的概念，其实也就是参数的一个外部调用标签。那么在调用时这些标签是否能够省略是有着以下规则的：</p>
<ol>
<li>在类型的init方法调用时是必须要加入参数标签的</li>
<li>在类的实例方法和类方法中，对其调用时Swift将忽略第一个参数的标签，而强制要求之后的参数名称</li>
<li>在全局方法中，所有的参数标签默认都是忽略掉得</li>
</ol>
<p>暂时就先说这么多了，后续有新的内容，会再添加补充。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前说了在学习swift过程中发现的一些和其他语言不同的点，最近在使用swift语言进行一个简单计算器的开发工作，在使用中又发现了一些需要注意的地方，这里就简单的说一下。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/tags/swift/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/categories/iOS/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift函数的一些注意点]]></title>
    <link href="http://www.ziank.cn/2015/03/18/swift-funciton/"/>
    <id>http://www.ziank.cn/2015/03/18/swift-funciton/</id>
    <published>2015-03-18T08:18:21.000Z</published>
    <updated>2015-03-18T09:16:24.000Z</updated>
    <content type="html"><![CDATA[<p>学习swift的过程中，简单说一下自己感觉swift和其他语言不太相同的几个注意点。</p>
<h3 id="1-_swift的函数的入参和返回值都可以是一个函数。">1. swift的函数的入参和返回值都可以是一个函数。</h3>
<a id="more"></a>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> voidFunc() -&gt; <span class="type">Void</span> {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="func"><span class="keyword">func</span></span> testFunc(<span class="type">Void</span>-&gt;<span class="type">Void</span>) -&gt; <span class="type">Void</span>-&gt;<span class="type">Void</span> {</div><div class="line">    <span class="keyword">return</span> voidFunc</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="2-_swift的函数返回值可以同时返回多个值">2. swift的函数返回值可以同时返回多个值</h3>
<p>swift的函数返回值可以是一个由多个数值组成的元组(tuple)，这样就可以同时返回多个数值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> testFunc(<span class="type">Void</span>-&gt;<span class="type">Void</span>) -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) {</div><div class="line">    <span class="keyword">return</span> (<span class="number">3</span>, <span class="number">4</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="3-_外部参数名">3. 外部参数名</h3>
<p>在swift的函数中，每一个参数都可以有本地参数名和外部参数名两个名称。<br>本地参数名就是定义函数名时，在参数列表中所写的参数名，它只可以在函数主体内使用；<br>外部参数名在函数定义时需要写在本地参数名之前，并使用空格将其分开。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> testFunc(outParam inParam:<span class="type">Int</span>) -&gt; <span class="type">Int</span> {</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>如上述代码中，外部参数名是outParam，本地参数名是inParam，在调用时需要写上外部参数名</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testFunc(outParam: <span class="number">123</span>)</div></pre></td></tr></table></figure>

<h3 id="4-_类里面的静态函数">4. 类里面的静态函数</h3>
<p>在swift类里面的静态函数，不能使用static关键字来修饰，而应该使用Class关键字来进行修饰</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>{</div><div class="line">    <span class="keyword">class</span> <span class="func"><span class="keyword">func</span></span> testFunc() {</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="5-_ViewController和xib文件的对应">5. ViewController和xib文件的对应</h3>
<p>除了和OC一样在xib里面设置对应的Class以外，由于swift不会自动调用xib的初始化，所以需要手动添加对应的初始化函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewController</span>: <span class="title">UIViewController</span> </span>{</div><div class="line">    convenience <span class="keyword">override</span> <span class="keyword">init</span>() {</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> nibNameOrNil = <span class="type">String</span>?(<span class="string">"TestViewController"</span>)</div><div class="line">        </div><div class="line">        <span class="comment">//考虑到xib文件可能不存在或被删，故加入判断</span></div><div class="line">        <span class="keyword">if</span> <span class="type">NSBundle</span>.mainBundle().pathForResource(nibNameOrNil, ofType: <span class="string">"nib"</span>) == <span class="built_in">nil</span> {</div><div class="line">            nibNameOrNil = <span class="built_in">nil</span></div><div class="line">        }</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: <span class="built_in">nil</span>)</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(nibName nibNameOrNil: <span class="type">String</span>?, bundle nibBundleOrNil: <span class="type">NSBundle</span>?) {</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</div><div class="line">    }</div><div class="line">    </div><div class="line">    required <span class="keyword">init</span>(coder aDecoder: <span class="type">NSCoder</span>) {</div><div class="line">        fatalError(<span class="string">"init(coder:) has not been implemented"</span>)</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<p>学习swift的过程中，简单说一下自己感觉swift和其他语言不太相同的几个注意点。</p>
<h3 id="1-_swift的函数的入参和返回值都可以是一个函数。">1. swift的函数的入参和返回值都可以是一个函数。</h3>
]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/tags/swift/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
      <category term="swift" scheme="http://www.ziank.cn/categories/iOS/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos之场景转换（Transitions)]]></title>
    <link href="http://www.ziank.cn/2015/03/11/cocos-scene/"/>
    <id>http://www.ziank.cn/2015/03/11/cocos-scene/</id>
    <published>2015-03-11T07:58:12.000Z</published>
    <updated>2015-03-11T08:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>我们在基础概念一节讲过修改当前场景的常见方式有三种，pushScene，replaceScene和popScene；但是切换场景使用的效果则会有很多种，例如淡入淡出，放大缩小，跳动等等。<br>Cocos提供了这种在两个场景之间直接进行转换的能力，在技术上讲，一个场景转换就是在展示并控制一个新场景之前执行的一个切换效果。<br><a id="more"></a></p>
<p>场景之间通过TransitionScene系列类来实现过渡跳转的效果。TransitionScene继承于Scene，该系列类主要是与场景切换特效相关的一些使用类。如TransitionFadeDown、TransitionPageTurn、TransitionJumpZoom等等。</p>
<h3 id="切换特效">切换特效</h3>
<p>在Cocos中提供的场景切换特效主要由以下几种：</p>
<ul>
<li>TransitionRotoZoom    旋转进入</li>
<li>TransitionJumpZoom    跳动进入</li>
<li>TransitionPageTurn    翻页效果进入</li>
<li>TransitionRadialCCW   钟摆效果</li>
<li>TransitionMoveInL / TransitionMoveInR / TransitionMoveInT / TransitionMoveInB     左侧/右侧/顶部/底部进入</li>
<li>TransitionSlideInL / TransitionSlideInR / TransitionSlideInT / TransitionSlideInB  分别从左侧/右侧/顶部/底部滑入</li>
<li>TransitionShrinkGrow  交替进入</li>
<li>TransitionFlipX/TransitionFlipY   X轴翻入（左右）/Y轴翻入</li>
<li>TransitionFlipAngular 左上右下轴翻入</li>
<li>TransitionFadeTR ／TransitionFadeBL／TransitionFadeUp／TransitionFadeDown    小方格右上角显示进入／ 小方格左下角显示进入／ 横条向上显示进入／ 横条向下显示进入</li>
<li>TransitionSplitCols ／ TransitionSplitRows 竖条切换进入／ 横条切换进入</li>
<li>TransitionZoomFlipAngular 左上右下轴翻入放大缩小效果</li>
<li>TransitionFade 渐隐进入</li>
<li>TransitionCrossFade 渐变进入</li>
<li>TransitionTurnOffTiles 小方格消失进入</li>
<li>TransitionRadialCCW／TransitionRadialCW 扇面展开收起</li>
</ul>
<p>场景转换的实现代码一般如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> transitions = TransitionMoveInL::create(<span class="number">0.2f</span>, scene);</div><div class="line">Director::getInstance()-&gt;replaceScene(transitions);</div></pre></td></tr></table></figure>

<p>场景的转换是由Director类来控制的，通过调用Director类的replaceScene(Scene scene）方法可直接使用传入scene替换当前场景来切换画面，当前场景会被释放，它是切换场景时最常用的方法。<br>前面说过，场景转换的一系列类都继承于Scene类，所以可以创建一个转换场景的对象代替scene，从而实现各种转换场景的效果。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在基础概念一节讲过修改当前场景的常见方式有三种，pushScene，replaceScene和popScene；但是切换场景使用的效果则会有很多种，例如淡入淡出，放大缩小，跳动等等。<br>Cocos提供了这种在两个场景之间直接进行转换的能力，在技术上讲，一个场景转换就是在展示并控制一个新场景之前执行的一个切换效果。<br>]]>
    
    </summary>
    
      <category term="Cocos" scheme="http://www.ziank.cn/tags/Cocos/"/>
    
      <category term="Cocos" scheme="http://www.ziank.cn/categories/Cocos/"/>
    
      <category term="文档" scheme="http://www.ziank.cn/categories/Cocos/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何把UIButton中的图片和文字上下对齐]]></title>
    <link href="http://www.ziank.cn/2015/03/06/edgeInsets/"/>
    <id>http://www.ziank.cn/2015/03/06/edgeInsets/</id>
    <published>2015-03-06T02:27:08.000Z</published>
    <updated>2015-03-11T07:56:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>我们都知道在UIButton中可以设置图片和文字，也经常见到同时设置有图片和下方提示文字的按钮，但是当我自己去对图片按钮添加提示文字的时候，却发现这并不是想象中的那么简单。</p>
<p><a id="more"></a></p>
<h2 id="设置图片和文字">设置图片和文字</h2>
<p>如示例代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> initView() -&gt; <span class="type">Void</span> {</div><div class="line"><span class="keyword">var</span> button:<span class="type">UIButton</span> = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>))</div><div class="line"></div><div class="line">button.setImage(<span class="type">UIImage</span>(named: <span class="string">"button.png"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.setTitle(<span class="string">"按钮"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.backgroundColor = <span class="type">UIColor</span>.blueColor()</div><div class="line"></div><div class="line"><span class="keyword">self</span>.view.addSubview(button)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以通过UIButton的setTitle和setImage方法分别为按钮设置图片和文字信息，但是会发现设置完成以后我们的图片和文字并没有重合排列，也没有上下排列，而是一个左右排列的样子。<br><img src="/img/button_image1.png" alt="设置图片和文字"></p>
<p>说到这里，肯定会有人想到设置图片和文字的frame来进行处理，而且我们也确实可以通过UIButton的对象获取到对应的imageView和titleLabel，但是如果经过测试的话，你就会发现这是一个trike的方法，而且是不生效的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> initView() -&gt; <span class="type">Void</span> {</div><div class="line"><span class="keyword">var</span> button:<span class="type">UIButton</span> = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>))</div><div class="line"></div><div class="line">button.setImage(<span class="type">UIImage</span>(named: <span class="string">"button.png"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.setTitle(<span class="string">"按钮"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.backgroundColor = <span class="type">UIColor</span>.blueColor()</div><div class="line">button.titleLabel?.frame = <span class="type">CGRectMake</span>(<span class="number">20</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>)</div><div class="line">button.imageView?.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>)</div><div class="line"></div><div class="line"><span class="keyword">self</span>.view.addSubview(button)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>修改为这样以后，运行程序，会发现对应的视图没有任何变化。<br><img src="/img/button_image2.png" alt="添加frame设置"></p>
<h2 id="UIEdgeInsets">UIEdgeInsets</h2>
<p>查看UIButton的属性，我们会找到titleEdgeInsets和imageEdgeInsets两个属性。修改这两个属性，可以实现我们想要的效果。<br>titleEdgeInsets和imageEdgeInsets都是UIEdgeInsets的对象，我们先说一下UIEdgeInsets的几个属性的具体效果。<br>我们知道，UIEdgeInsets有top，left，bottom，right几个属性，但是通过测试，就会发现设置了top以后自己的y坐标并没有增加响应的距离，而是增加了1/2，那么它们到底应该如何计算呢？<br>当设置了top以后，其实就是相当于view的<strong>上边缘</strong>向下移动了相应的距离。用在title中，如果titleLabel的frame(50, 50, 24, 24);那么Button的上下边缘应该分别是0和124，因为正常情况下titleLabel必然处于Button的中间位置。当设置了titleEdgeInsets的top为10以后，相当于button的上下坐标为10，124，则titleLabel的坐标就变成了(50, 55, 24, 24)，也就是上下边缘变为了55和79， 向下移动了5个点。</p>
<p>经过计算可以得出，如果要将文字移动到图片的下方，需要设置titleEdgeInsets和imageEdgeInsets，且分别设置为<br>若titleLabel为 w1,h1, imageView为w2,h2, 上下间距为space<br>titleEdgeInsets = (h2 + space, - w2, 0, 0)<br>imageEdgeInsets = (-h1 - space, w1)<br>如上述例子若改为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="func"><span class="keyword">func</span></span> initView() -&gt; <span class="type">Void</span> {</div><div class="line"><span class="keyword">var</span> button:<span class="type">UIButton</span> = <span class="type">UIButton</span>(frame: <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">100</span>))</div><div class="line"></div><div class="line">button.setImage(<span class="type">UIImage</span>(named: <span class="string">"button.png"</span>), forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.setTitle(<span class="string">"按钮"</span>, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</div><div class="line">button.backgroundColor = <span class="type">UIColor</span>.blueColor()</div><div class="line"></div><div class="line"><span class="keyword">var</span> imageSize:<span class="type">CGSize</span> = button.imageView!.frame.size</div><div class="line"><span class="keyword">var</span> titleSize:<span class="type">CGSize</span> = button.titleLabel!.frame.size</div><div class="line">button.titleEdgeInsets = <span class="type">UIEdgeInsets</span>(top: <span class="number">0</span>, <span class="keyword">left</span>:-imageSize.width, bottom: -imageSize.height - <span class="number">5</span>, <span class="keyword">right</span>: <span class="number">0</span>)</div><div class="line">button.imageEdgeInsets = <span class="type">UIEdgeInsets</span>(top: -titleSize.height - <span class="number">5</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: -titleSize.width)</div><div class="line"><span class="keyword">self</span>.view.addSubview(button)</div><div class="line">}</div></pre></td></tr></table></figure>

<p>则可实现我们要求的效果：<br><img src="/img/button_image3.png" alt="设置insets"></p>
<p><strong>注意：如果设置了button的frame，而且button的宽度不足以同时显示图片和文字的大小的话，titleLabel的size将会获取错误。所以如果需要设置frame，建议先将button的宽度设置为frame.size.width * 2, 等titleEdgeInsets和imageEdgeInsets全部设置完成以后再重新设置frame。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2>
<p>我们都知道在UIButton中可以设置图片和文字，也经常见到同时设置有图片和下方提示文字的按钮，但是当我自己去对图片按钮添加提示文字的时候，却发现这并不是想象中的那么简单。</p>
<p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos之图像渲染与动画]]></title>
    <link href="http://www.ziank.cn/2015/03/05/cocos-image/"/>
    <id>http://www.ziank.cn/2015/03/05/cocos-image/</id>
    <published>2015-03-05T07:30:55.000Z</published>
    <updated>2015-03-05T07:40:10.000Z</updated>
    <content type="html"><![CDATA[<p>本文主要描述坐标系和Action（动作）的一些基本概念。</p>
<h3 id="坐标系">坐标系</h3>
<p>Cocos2d的坐标系是和OpenGL坐标系一样，原点为屏幕的左下角，然后X轴向右，Y轴向上。<br><a id="more"></a></p>
<p>将一个节点添加到父节点里面时，需要设置其在父节点上的位置，本质上是设置节点的锚点在父节点坐标系上的位置。</p>
<ul>
<li>Anchor Point的两个参数都在0~1之间。它们表示的并不是像素点，而是乘数因子。(0.5, 0.5)表示Anchor Point位于节点长度乘0.5和宽度乘0.5的地方，即节点的中心</li>
<li>在Cocos2d-x中Layer的Anchor Point为默认值(0, 0)，其他Node的默认值为(0.5, 0.5)。<br>锚点（Anchor Point）</li>
</ul>
<h3 id="Action(动作)">Action(动作)</h3>
<p>Action是所有动作的基类，它创建的一个对象代表一个动作。动作作用于Node，因此每个动作都需要由Node对象执行。Action作为基类，实际上是一个接口，动作类的大多数实现类都派生于有限时间动作类(FiniteTimeAction)。</p>
<p>在实际开发中我们通常用到两类动作-即时动作(ActionInstant)和持续动作(ActionInterval)，它们均继承于有限时间动作类。<br>我们一般用的动作类如下图：<br><img src="/img/cocos_action.png" alt="常用动作类关系"></p>
<h4 id="ActionInstant(即时动作)">ActionInstant(即时动作)</h4>
<p>即时动作是指能够立刻完成的动作，这类动作是在下一帧立刻完成的动作，如设定位置、设定缩放等。把它们包装成动作后，可以与其他动作类组合为复杂动作。<br>下面介绍一下常用的即时动作：</p>
<ul>
<li>Place<br>该动作用于将节点放置到某个指定位置，起作用与修改节点的position属性相同。例如将节点放到屏幕坐标(10,10)处的代码应该如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> placeAction = Place::create(Point(<span class="number">10</span>, <span class="number">10</span>));</div></pre></td></tr></table></figure>

<ul>
<li>FlipX和FlipY<br>这两个动作分别用于将节点沿X轴和Y轴反向显示，起作用与设置精灵的FlipX和FlipY属性相同，将其包装成动作是为了便于和其他动作进行组合。<br>下面代码将一个Sprit移动到一端后反向显示再移回原点的动作：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> flipxAction = FlipX::create(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">auto</span> moveTo = MoveTo::create(<span class="number">0.4f</span>, Point(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line"><span class="keyword">auto</span> action = Sequence::create(moveTo, flipxAction, moveTo-&gt;reverse(), NULL);</div></pre></td></tr></table></figure>

<ul>
<li>Show和Hide<br>这两个动作分别用于现实和隐藏节点，起作用和设置节点的visible属性作用一致。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> hideAction = Hide::create();</div><div class="line"><span class="keyword">auto</span> moveTo = MoveTo::create(<span class="number">0.4f</span>, Point(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line"><span class="keyword">auto</span> action = Sequence::create(moveTo, hideAction, NULL);</div></pre></td></tr></table></figure>

<ul>
<li>CallFunc<br>CallFunc系列动作包括CallFunc、CallFuncN两个动作，用来在动作中进行方法调用。在游戏中为了节约内存资源，我们可以在动作完成后调用相应函数清理内存，如下代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> actionMoveDone = CallFuncN::create([&](http:<span class="comment">//cn.cocos2d-x.org/doc/cocos-docs-master/manual/framework/native/v3/action/Ref* sender){</span></div><div class="line">    <span class="built_in">log</span>(<span class="string">"Clear memory"</span>);</div><div class="line">});</div><div class="line"><span class="keyword">auto</span> moveTo = MoveTo::create(<span class="number">0.4f</span>, Point(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line"><span class="keyword">auto</span> action = Sequence::create(moveTo, actionMoveDone, NULL);</div></pre></td></tr></table></figure>

<ul>
<li>RemoveSelf<br>RemoveSelf动作用于删除节点，常用于某项动作完成后删除动作节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>-&gt;runAction(Sequence::create(</div><div class="line"><span class="keyword">this</span>-&gt;runAction(Sequence::create(</div><div class="line">CallFunc::create(CC_CALLBACK_0(UI_Config::TestLogic,<span class="keyword">this</span>)),</div><div class="line">DelayTime::create(<span class="number">0.2f</span>),</div><div class="line">RemoveSelf::create(<span class="keyword">true</span>),</div><div class="line"><span class="keyword">nullptr</span>));</div></pre></td></tr></table></figure>

<ul>
<li><p>ReuseGrid和StopGrid<br>这两个动作分别是重复网格动作和停止网格动作。和持续动作中的GridAction（网格动作）关联使用。</p>
</li>
<li><p>ToggleVisibility<br>切换节点的可视属性。该动作相当于visible属性发生变化。</p>
</li>
<li><p>CCBSetSpriteFrame<br>用坐标创建一个位置动作，用于设置Sprite的位置</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CCSequence::createWithTwoActions(CCDelayTime::create(duration), CCBSetSpriteFrame::create((CCSpriteFrame *)pKeyframe1-&gt;getValue()));</div></pre></td></tr></table></figure>

<ul>
<li>CCBSoundEffect<br>播放声音效果</li>
</ul>
<h4 id="ActionInterval(持续动作)">ActionInterval(持续动作)</h4>
<ul>
<li><p>属性变化动作<br>属性变化动作通过属性值的逐渐变化来实现动画效果。需要注意的是XXTo和XXBy的区别在于XXTo是表示最终值，而XXBy则表示向量——改变值。<br>MoveTo和MoveBy          移动<br>JumpTo和JumpBy          跳跃<br>BezierTo和BezierBy      曲线运动<br>ScaleTo和ScaleBy        缩放动作<br>RotateTo和RotateBy      旋转动作</p>
</li>
<li><p>视觉特效动作<br>该类用来实现特殊视觉效果。<br>FadeIn, FadeOut和FateTo 淡入、淡出和透明效果<br>TintTo和TintBy          设置色调变化<br>Blink                   闪烁效果<br>Animation               帧动画效果</p>
</li>
<li><p>复合动作<br>通常在开发中我们需要将各种动作组合起来再让节点执行，复合动作的作用就是将各种动作组合在一起。而且，复合动作本身也是动作。因此可以作为一个普通动作嵌入到其他动作中。</p>
<blockquote>
<p>注意：Sequence动作不能嵌入其他复合动作内使用，DelayTime不属于复合动作，但是只能在复合动作内使用。</p>
</blockquote>
</li>
</ul>
<p>DelayTime               延时动作<br>Repeat/RepeatForever    重复执行某个动作<br>Spawn                   同时执行两个动作<br>Sequence                顺序执行多个动作</p>
<ul>
<li>变速动作<br>变速动作和复合动作类似，也是一种特殊的动作，它可以把任何动作按照改变后的速度执行。</li>
</ul>
<ul>
<li>Speed<br>用于线性的改变某个动作的速度，为了改变一个动作的速度，首先需要将目标动作包装到Speed动作中：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> repeat = RepeatForever::create(animation);</div><div class="line"><span class="keyword">auto</span> speed = Speed::create(repeat, <span class="number">0.5f</span>);</div><div class="line">sprite-&gt;runAction(speed);</div></pre></td></tr></table></figure>

<p>第二个参数为变速比例，设置为0.5f则速度为原来一半。</p>
<ul>
<li>ActionEase<br>Speed虽然能改变动作的速度，但是只能按比例改变速度，ActionEase可以实现动作的速度又快到慢、速度随时间改变的匀速运动。该类包含5类运动，指数缓冲、Sine缓冲、弹性缓冲、跳跃缓冲和回震缓冲。每类运动都包含3个不同时期的变换：In、Out和InOut。</li>
</ul>
<p><em>以上内容基本来自<a href="http://cn.cocos2d-x.org/article/index?type=cocos2d-x" target="_blank" rel="external">官方文档</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要描述坐标系和Action（动作）的一些基本概念。</p>
<h3 id="坐标系">坐标系</h3>
<p>Cocos2d的坐标系是和OpenGL坐标系一样，原点为屏幕的左下角，然后X轴向右，Y轴向上。<br>]]>
    
    </summary>
    
      <category term="Cocos" scheme="http://www.ziank.cn/tags/Cocos/"/>
    
      <category term="Cocos" scheme="http://www.ziank.cn/categories/Cocos/"/>
    
      <category term="文档" scheme="http://www.ziank.cn/categories/Cocos/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cocos之基本概念]]></title>
    <link href="http://www.ziank.cn/2015/03/02/cocos-basic/"/>
    <id>http://www.ziank.cn/2015/03/02/cocos-basic/</id>
    <published>2015-03-02T05:53:30.000Z</published>
    <updated>2015-03-11T08:01:40.000Z</updated>
    <content type="html"><![CDATA[<p>Cocos中有DirectorScene，Layer，Sprit等几个基本的概念，他们都是派生于Node的子类，可以通过执行Action来修改游戏节点的属性。在Cocos2d-x-3.x引擎中，采用树形结构来管理游戏对象，一个游戏可以划分为不同的Scene，一个Scene又可以分为不同的Layer，一个Layer又可以拥有任意个可见的Sprit。<br><a id="more"></a><br>在每一个时刻，都会有一个Scene在独立的运行，通过切换Scene来完成一个游戏流程，游戏流程的管理有Director来执行，其基本架构类图如下：<br><img src="/img/class_relateion.png" alt="基本架构类图"></p>
<h3 id="Director">Director</h3>
<p>Director是整个cocos-2dx引擎的核心，是整个游戏的导航仪，一些游戏的常用操作都是由Director来进行控制完成的，比如场景切换，游戏暂停，坐标转换等等。<br>由于在游戏中会使用Director控制整个游戏的流程，所以Director类的设计是单例模式的，也就是说整个游戏项目中取到的Director对象都是同一个，通常使用getInstance() 方法取得Director的实例。</p>
<h3 id="Scene(场景)">Scene(场景)</h3>
<p>Scene也是cocos2dx中必不可少的元素，游戏中通常我们需要构建不同的Scene（至少一个），游戏里关卡、版块的切换也就是一个一个Scene的切换，就像在电影中变换舞台和场地一样。Scene的一个重要的作用就是流程控制的作用，我们可以通过Director的一系列方法控制游戏中不同的Scene的自由切换。<br>下面是Director控制场景的常用方法：</p>
<ul>
<li>runWithScene( Scene *scene )<br>启动游戏，并运行scene场景。本方法在主程序第一次启动主场景的时候调用。如果已有正在运行的场景则不能调用该方法；会调用pushScene—&gt;startAnimation。</li>
<li>pushScene( Scene *scene )<br>将当前运行中的场景暂停并压入到代码执行场景栈中，再将传入的scene设置为当前运行场景，只有存在正在运行的场景时才调用该方法；</li>
<li>replaceScene( Scene *scene ) 直接使用传入的scene替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。</li>
<li>popScene() 释放当前场景，再从代码执行场景中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。和PushScene结对使用</li>
<li>end() 释放和终止执行场景，同时退出应用</li>
<li>pause() 暂停当前运行场景中的所有计时器和动作，场景仍然会显示在屏幕上</li>
<li>resume () 恢复当前运行场景的所有计时器和动作，场景仍然会显示在屏幕上</li>
</ul>
<p>同时场景是层的容器，包含了所有需要显示的游戏元素。通常，当我们需要完成一个场景时候，会创建一个Scene的子类，并在子类中实现我们需要的功能。比如，我们可以在子类的初始化中载入游戏资源，为场景添加层，启动音乐播放等等。</p>
<h3 id="Layer(层)">Layer(层)</h3>
<p>Layer是处理玩家事件响应的Node子类。与场景不同，层通常包含的是直接在屏幕上呈现的内容，并且可以接受用户的输入事件，包括触摸，加速度计和键盘输入等。我们需要在层中加入精灵，文本标签或者其他游戏元素，并设置游戏元素的属性，比如位置，方向和大小；设置游戏元素的动作等。通常，层中的对象功能类似，耦合较紧，与层中游戏内容相关的逻辑代码也编写在层中，在组织好层后，只需要把层按照顺序添加到场景中就可以显示出来了。要向场景添加层，我们可以使用addChild方法。</p>
<p>addChild( Node child ) addChild( Node child, int zOrder ) addChild( Node *child, int zOrder, int tag )</p>
<p>其中，Child参数就是节点。对于场景而言，通常我们添加的节点就是层。先添加的层会被置于后添加的层之下。如果需要为它们指定先后次序，可以使用不同的zOrder值。tag是元素的标识号码，如果为子节点设置了tag值，就可以在它的父节点中利用tag值就可以找到它了。层可以包含任何Node作为子节点，包括Sprites(精灵), Labels(标签)，甚至其他的Layer对象。</p>
<h3 id="Sprit(精灵)">Sprit(精灵)</h3>
<p>Cocos2d中的精灵和其他游戏引擎中的精灵相似，它可以移动，旋转，缩放，执行动画，并接受其他转换。Cocos2dx的Sprite由Texure，frame和animation组成，由openes负责渲染。</p>
<p>简单过程可描述为：<br>使用Texture2D加载图片，可以用Texture2D生成对应的SpriteFrame（精灵帧），将SpriteFrame添加到Animation生成动画数据，用Animation生成Animate（就是最终的动画动作），最后用Sprite执行这个动作。<br>创建精灵的几种方式：</p>
<p>直接创建:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"HelloWorld.png"</span>);      </div><div class="line"><span class="keyword">this</span>-&gt;addChild(sprite,<span class="number">0</span>);</div></pre></td></tr></table></figure>

<p>使用纹理来创建精灵:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> sprite1 = Sprite::createWithTexture(TextureCache::getInstance()-&gt;addImage(<span class="string">"HelloWorld.png"</span>));</div><div class="line"><span class="keyword">this</span>-&gt;addChild(sprite1, <span class="number">0</span>);</div></pre></td></tr></table></figure>

<p>使用精灵帧来创建精灵:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> sprite2=Sprite::createWithSpriteFrameName(<span class="string">"HelloWorld.png"</span>);　　</div><div class="line"><span class="keyword">this</span>-&gt;addChild(sprite2, <span class="number">0</span>);</div></pre></td></tr></table></figure>

<p>在Cocos2dx中实现精灵显示的基本过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建Scene</span></div><div class="line"><span class="keyword">auto</span> scene = Scene::create();</div><div class="line"><span class="comment">//创建层</span></div><div class="line"><span class="keyword">auto</span> layer = HelloWorld::create();</div><div class="line"><span class="comment">//把层加入场景中</span></div><div class="line">scene-&gt;addChild(layer);</div><div class="line"><span class="comment">//创建一个精灵</span></div><div class="line"><span class="keyword">auto</span> sprite = Sprite::create(<span class="string">"HelloWorld.png"</span>);</div><div class="line"><span class="comment">//把精灵加到层里</span></div><div class="line">layer-&gt;addChild(sprite, <span class="number">0</span>);</div></pre></td></tr></table></figure>

<p><em>以上内容基本来自<a href="http://cn.cocos2d-x.org/article/index?type=cocos2d-x" target="_blank" rel="external">官方文档</a></em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Cocos中有DirectorScene，Layer，Sprit等几个基本的概念，他们都是派生于Node的子类，可以通过执行Action来修改游戏节点的属性。在Cocos2d-x-3.x引擎中，采用树形结构来管理游戏对象，一个游戏可以划分为不同的Scene，一个Scene又可以分为不同的Layer，一个Layer又可以拥有任意个可见的Sprit。<br>]]>
    
    </summary>
    
      <category term="Cocos" scheme="http://www.ziank.cn/tags/Cocos/"/>
    
      <category term="Cocos" scheme="http://www.ziank.cn/categories/Cocos/"/>
    
      <category term="文档" scheme="http://www.ziank.cn/categories/Cocos/%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UILabel的使用]]></title>
    <link href="http://www.ziank.cn/2015/01/29/UILable_CoreText/"/>
    <id>http://www.ziank.cn/2015/01/29/UILable_CoreText/</id>
    <published>2015-01-29T06:19:18.000Z</published>
    <updated>2015-03-02T06:39:30.000Z</updated>
    <content type="html"><![CDATA[<p>[TOC]</p>
<p>我们都知道UILabel是iOS开发中最常用和最简单的一个组件，可以用来显示文本内容。但是一般来说我们都只是用UILabel现实固定字体、颜色设置的文本，其实我们也可以用UILabel同时显示多种字体和颜色的问题，甚至可以在文字中添加图片进行显示。<br><a id="more"></a></p>
<h2 id="UILabel使用的几种方式">UILabel使用的几种方式</h2>
<p>下面简单说一下UILabel使用的三种方式，或者说是个人理解的UILabel使用的三种境界吧。</p>
<ol>
<li>设置UILabel的字体和颜色，现实特定文本内容。</li>
<li>通过attributedText在UILabel中显示不同字体和颜色的文本内容，以及在文本之中插入图片。</li>
<li>通过CoreText重写drawRect在UILabel中显示更为复杂的内容。</li>
</ol>
<h3 id="1-_UILabel的基本使用">1. UILabel的基本使用</h3>
<p>对于UILabel，我们平时最常用也是最简单的使用方式就是创建一个label，然后设置其字体和颜色，进行显示就可以了。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:CGRectMake(<span class="number">50</span>, <span class="number">300</span>, <span class="number">200</span>, <span class="number">44</span>)];</div><div class="line">textLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</div><div class="line">textLabel<span class="variable">.text</span> = <span class="string">@"Simple Text Label!"</span>;</div><div class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textLabel];</div></pre></td></tr></table></figure>

<p>上面的代码就是创建了一个UILabel，显示红色，12号字体的一段文字，实际结果如图：<br><img src="/img/simple_uilabel_demo.png" alt="UILabel的基本使用"></p>
<h3 id="2-_UILabel的attributeText使用">2. UILabel的attributeText使用</h3>
<p>UILabel除了基本使用以外，还可以通过attributeText在同一个Label中设置多种字体和颜色，甚至插入图片等内容。我们还是用一个例子来说明：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] initWithFrame:CGRectMake(<span class="number">50</span>, <span class="number">300</span>, <span class="number">300</span>, <span class="number">44</span>)];</div><div class="line">textLabel<span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</div><div class="line">textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> greenColor];</div><div class="line"></div><div class="line"></div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:<span class="string">@"测试多种字体显示"</span>] ;</div><div class="line"><span class="comment">//为所有文本设置字体</span></div><div class="line">[attributedString addAttribute:NSFontAttributeName value:[<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">24</span>] range:NSMakeRange(<span class="number">0</span>, [attributedString length])];</div><div class="line"></div><div class="line"><span class="comment">//将“测试”两字字体颜色设置为蓝色</span></div><div class="line">[attributedString addAttribute:NSForegroundColorAttributeName value:[<span class="built_in">UIColor</span> blueColor] range:NSMakeRange(<span class="number">0</span>, <span class="number">2</span>)];</div><div class="line"></div><div class="line"><span class="comment">//将“多种字体”四个字字体颜色设置为红色</span></div><div class="line">[attributedString addAttribute:NSForegroundColorAttributeName value:[<span class="built_in">UIColor</span> redColor] range:NSMakeRange(<span class="number">2</span>, <span class="number">4</span>)];</div><div class="line"></div><div class="line"><span class="comment">//在“测”和“试”两字之间插入一张图片</span></div><div class="line"><span class="built_in">NSString</span> *imageName = <span class="string">@"feiji.png"</span>;</div><div class="line">NSTextAttachment *imageAttachment = [[NSTextAttachment alloc] init];</div><div class="line">imageAttachment<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:imageName];</div><div class="line">NSAttributedString *imageAttributedString = [NSAttributedString attributedStringWithAttachment:imageAttachment];</div><div class="line">[attributedString insertAttributedString:imageAttributedString atIndex:<span class="number">1</span>];</div><div class="line"></div><div class="line"></div><div class="line">textLabel<span class="variable">.attributedText</span> = attributedString;</div><div class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textLabel];</div></pre></td></tr></table></figure>

<p>最后Label上显示的结果如下图，可以看到把图片<code>&quot;feiji.png&quot;</code>插入到了Label的文字之中。<br><img src="/img/attributeText_label.png" alt="使用attributeText在UILabel上显示多种字体"></p>
<h3 id="3-_使用drawRect重绘Label">3. 使用drawRect重绘Label</h3>
<p>关于第三点我们一般都用不到，下一节我们在具体分析。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[TOC]</p>
<p>我们都知道UILabel是iOS开发中最常用和最简单的一个组件，可以用来显示文本内容。但是一般来说我们都只是用UILabel现实固定字体、颜色设置的文本，其实我们也可以用UILabel同时显示多种字体和颜色的问题，甚至可以在文字中添加图片进行显示。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object-C runtime之消息（2）]]></title>
    <link href="http://www.ziank.cn/2015/01/26/runtime-message-2/"/>
    <id>http://www.ziank.cn/2015/01/26/runtime-message-2/</id>
    <published>2015-01-26T07:46:58.000Z</published>
    <updated>2015-03-02T06:39:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="消息的工作流程">消息的工作流程</h2>
<p>上一节我们主要讲了消息相关的SEL和IMP的概念，同时也了解到消息最后都会转换成类似objc_msgSend的消息函数来执行，那么 objc_msgSend 到底是怎么工作的呢？<br><a id="more"></a><br>在Objective-C中，消息直到运行时才会绑定到方法的实现上。编译器会把代码中<code>[receiver message]</code>转换成 objc_msgSend消息函数，这个函数完成了动态绑定的所有事情。它的运行流程如下:<br><img src="/img/message_flow.png" alt="消息处理流程"></p>
<ol>
<li><p>检查receiver是否为nil，如果为nil，直接cleanup，然后return。这也是我们可以向nil发送消息的原因。</p>
</li>
<li><p>检查message对应的selector是否需要忽略。(ps: Mac开发中开启GC就会忽略retain,release方法。)</p>
</li>
<li><p>在receiver对应的Class中根据Selector去找IMP</p>
<blockquote>
<p>在Class中寻找IMP的过程:</p>
<ol>
<li>查找当前class的cache方法列表（cache methodLists）里去找<br>找到了，跳到对应函数实现；</li>
<li>没找到，就从class的方法列表（methodLists）里查找；</li>
</ol>
</blockquote>
</li>
<li><p>如果在receiver对应的Class中没有找到，就到super class的方法列表里此处输入代码找，直到找到基类(NSObject)为止。</p>
</li>
<li><p>如果在所有的super Class 方法中都没有找到，就会走到动态方法解析的流程中。动态方法解析是说你可以动态地提供一个方法的实现。<br>我们可以通过分别重载resolveInstanceMethod:和resolveClassMethod:方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在Cache和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用resolveInstanceMethod:或resolveClassMethod:来给程序员一次动态添加方法实现的机会。我们需要用class_addMethod函数完成向特定类添加特定方法实现的操作。<br>例如我们要添加一个名为<code>resolveThisMethodDynamically</code>的对象方法，那么我们就需要添加如下代码：</p>
</li>
</ol>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) {</div><div class="line"><span class="comment">// implementation ....</span></div><div class="line">}</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class="line">{</div><div class="line"><span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) {</div><div class="line">class_addMethod([<span class="keyword">self</span> class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</div><div class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">}</div><div class="line"><span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</div><div class="line">}</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>

<p>上面的例子为<code>resolveThisMethodDynamically</code>方法添加了实现内容，也就是<code>dynamicMethodIMP</code>方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">Type Encoding</a>。<br><br></p>
<ol>
<li>如果没有对消息进行动态方法解析处理，那么我们就会走到receiver重定向的流程。<br>重定向是runtime系统在消息转发机制执行前，给我们的又一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的receiver。</li>
</ol>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">{</div><div class="line"><span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:)){</div><div class="line"><span class="keyword">return</span> alternateObject;</div><div class="line">}</div><div class="line"><span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>毕竟进行消息转发要耗费更多时间，如果可以的画，抓住这次机会将消息重定向给其他对象进行处理是一个不错的选择。<strong>重定向绝对不可以返回self，因为那样会造成死循环。</strong><br><br></p>
<ol>
<li>消息转发<br>当动态方法解析不作处理返回NO时，也没有进行对象的重定向，那么消息转发机制就会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：</li>
</ol>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(NSInvocation *)anInvocation</div><div class="line">{</div><div class="line"><span class="keyword">if</span> ([someOtherObject respondsToSelector:</div><div class="line">[anInvocation selector]])</div><div class="line">[anInvocation invokeWithTarget:someOtherObject];</div><div class="line"><span class="keyword">else</span></div><div class="line">[<span class="keyword">super</span> forwardInvocation:anInvocation];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>最后，需要注意一点：<strong>如果想要通过动态方法解析、重定向或者是消息转发把对象A的消息message转发给另一个对象B的话，那么在A对象中必须没有消息message的对应处理，否则会转发失败。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="消息的工作流程">消息的工作流程</h2>
<p>上一节我们主要讲了消息相关的SEL和IMP的概念，同时也了解到消息最后都会转换成类似objc_msgSend的消息函数来执行，那么 objc_msgSend 到底是怎么工作的呢？<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Object-C runtime之消息（1）]]></title>
    <link href="http://www.ziank.cn/2015/01/21/runtime-message-1/"/>
    <id>http://www.ziank.cn/2015/01/21/runtime-message-1/</id>
    <published>2015-01-21T02:20:32.000Z</published>
    <updated>2015-03-02T09:44:02.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C在编译时不是把[receiver message]当成简单的方法调用，而是把[receiver message]转化为：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></div></pre></td></tr></table></figure>

<p>如果消息含有参数，则为：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, <span class="keyword">...</span>)</div></pre></td></tr></table></figure>

<p><a id="more"></a><br>如果消息的接收者receiver能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。</p>
<h2 id="什么是消息">什么是消息</h2>
<p>进入正题之前，我们首先要来说说跟message息息相关的几个概念：</p>
<blockquote>
<ol>
<li>message（消息）<br>message的具体定义很难说，因为并没有真正的代码描述，简单的讲message 是一种抽象，包括了函数名+参数列表，他并没有实际的实体存在。</li>
<li>method（方法）<br>method是真正的存在的代码。如：- (int)meaning { return 42; }</li>
<li>selector（方法选择器）<br>selector 通过SEL类型存在，描述一个特定的method 或者说 message。在实际编程中，可以通过selector进行检索方法等操作。</li>
</ol>
</blockquote>
<h2 id="两个跟消息相关的概念">两个跟消息相关的概念</h2>
<h3 id="1-_SEL">1. SEL</h3>
<p>SEL又叫做方法选择器，是objc_msgSend函数第二个参数类型，那它的定义到底是什么呢？<br>打开objc.h文件，看下SEL的定义如下:</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *SEL;</span></div></pre></td></tr></table></figure>

<p>SEL是一个指向objc_selector结构体的指针。而 objc_selector 的定义并没有在runtime.h中给出定义。我们可以尝试运行如下代码:</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SEL sel = <span class="keyword">@selector</span>(foo);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)sel);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, sel);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selName = [<span class="string">@"foo"</span> UTF8String];</div><div class="line">SEL sel2 = sel_registerName(selName);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)sel2);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, sel2);</div></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight Console"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> <span class="tag">foo</span></div><div class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> 0<span class="tag">x7fff8fde5114</span></div><div class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> <span class="tag">foo</span></div><div class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> 0<span class="tag">x7fff8fde5114</span></div></pre></td></tr></table></figure>

<p>Objective-C在编译时，会根据方法的名字生成一个用来区分这个方法的唯一的一个ID。<br><strong>只要方法名称相同，那么它们的ID就是相同的。</strong></p>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么它的SEL就是一样的。每一个方法都对应着一个SEL。编译器会根据每个方法的方法名为那个方法生成唯一的SEL。</p>
<p>这些SEL组成了一个Set集合，这个Set简单的说就是一个经过了优化过的hash表。而Set的特点就是唯一，也就是SEL是唯一的，因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了。</p>
<p>但是，有一个问题，就是数量增多会增大hash冲突而导致的性能下降（或是没有冲突，因为也可能用的是perfect hash）。但是不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL），那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>
<h3 id="2-_IMP">2. IMP</h3>
<p>不同的类可以拥有相同的selector。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br>IMP在objc.h中是如此定义的：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef id (*IMP)(id, SEL, <span class="keyword">...</span>);</div></pre></td></tr></table></figure>

<p>IMP的本质就是一个函数指针，它是由编译器生成的。当发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。<br>前面介绍过的SEL，其实就是为IMP服务的。由于每个方法都对应唯一的SEL，因此我们可以通过SEL方便、快速、准确的获得它所对应的IMP（也就是函数指针），而在取得了函数指针之后，也就意味着我们取得了执行的时候的这段方法的代码的入口，这样我们就可以像普通的C语言函数调用一样使用这个函数指针。</p>
<h2 id="传递消息所用的几个runtime方法">传递消息所用的几个runtime方法</h2>
<p>上篇文章中我们说过，下面的方法：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[receiver message]</div></pre></td></tr></table></figure>

<p>在编译后会变成：</p>
<figure class="highlight C++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure>

<p>实际上，同objc_msgSend方法类似的还有几个：</p>
<figure class="highlight Cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">objc_msgSend_stret      <span class="comment">//返回值是结构体</span></div><div class="line">objc_msgSend_fpret      <span class="comment">//返回值是浮点型 </span></div><div class="line">objc_msgSendSuper       <span class="comment">//调用父类方法 </span></div><div class="line">objc_msgSendSuper_stret <span class="comment">//调用父类方法，返回值是结构</span></div></pre></td></tr></table></figure>

<p>它们的作用都是类似的，为了简单起见，后续介绍消息和消息传递机制都以objc_msgSend方法为例。</p>
<p>下一节我们再继续讲述消息调用的流程。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Objective-C在编译时不是把[receiver message]当成简单的方法调用，而是把[receiver message]转化为：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></div></pre></td></tr></table></figure>

<p>如果消息含有参数，则为：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, <span class="keyword">...</span>)</div></pre></td></tr></table></figure>

<p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[能够自适应高度的TABLEVIEWCELL(SELF-SIZING CELL)]]></title>
    <link href="http://www.ziank.cn/2015/01/20/self-size-cell/"/>
    <id>http://www.ziank.cn/2015/01/20/self-size-cell/</id>
    <published>2015-01-20T10:30:50.000Z</published>
    <updated>2015-03-02T06:39:36.000Z</updated>
    <content type="html"><![CDATA[<p>在iOS8中，Apple为UITableView引入了一种名为Self-Sizing-Cells的新特性。这是新的SDK中最让我兴奋的一种特性。iOS8以前，如果你想要在tableview中显示可变高度的动态内容，必须单独计算每一个cell的高度。现在到了iOS8，Self-Sizing-Cell 提供了显示动态内容的一种解决方案。简言之，使用自适应cell，你只需要做下面几点：<br><a id="more"></a></p>
<blockquote>
<ul>
<li>使用autolayout定义cell的约束条件</li>
<li>设置tableview的row的估计高度</li>
<li>设置tableview的rowHeight属性为UITableViewAutomaticDimension</li>
</ul>
</blockquote>
<p>如果用代码来表示后两点的话，看起来大概是这个样子的：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tableView.<span class="variable">estimatedRowHeight =</span> <span class="number">44.0</span></div><div class="line"></div><div class="line">tableView.<span class="variable">rowHeight =</span> UITableViewAutomaticDimension</div></pre></td></tr></table></figure>

<p>只需要两行代码，你就可以让tableview根据内容计算cell的尺寸并自动渲染它。使用Self-Sizing-Cell特性能够节约你的时间和代码量，相信你会喜欢它的。</p>
<h2 id="使用Self-Sizing-cell创建一个简单地示例">使用Self-Sizing-cell创建一个简单地示例</h2>
<p>学习一个新特性最好的办法就是使用它。让我们用一个demo程序来示范Self-Sizing-cell的使用。 首先又一个模板工程，这是一个显示酒店列表的简单app。每一个cell包括两行文字，分别是酒店的名字和地址。如果你下载并执行该程序的话，效果应该如下：<br><img src="/img/table-view-truncated-text.png" alt="示例图片"><br>正如你所看到的，由于每个row的高度都是固定的，一些酒店的地址被截断了。你可能在开发基于tableview的应用时也会遇到同样地问题。在过去，你可能简单地缩小字体或者增加文本行数来修复这个问题。从iOS8以后，你需要做的就是使用Self-Sizing-Cell，这样cell就会根据内容进行合适适配，无论内容的长度如何变化，都能够正常的显示。</p>
<h2 id="添加AutoLayout的约束">添加AutoLayout的约束</h2>
<p>你可能讨厌AutoLayout并且在尽量的避免使用它。但是，不使用AutoLayout，Self-Sizing-Cell就不恩能够够正常的工作，因为它是根据autoLayout的约束来确定正确地rowHeight的。实际上，是tableview在每一个cell上调用了systemLayoutSizeFittingSize来返回基于layout约束计算出的cell尺寸。<br><br><br>请对name和address的两个label自行添加相应约束。</p>
<h2 id="设置预估的cell高度">设置预估的cell高度</h2>
<p>添加了AutoLayout的约束之后，剩下的就是在viewDidLoad方法中添加下面的代码：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tableView.<span class="variable">estimatedRowHeight =</span> <span class="number">68.0</span></div><div class="line">tableView.<span class="variable">rowHeight =</span> UITableViewAutomaticDimension</div></pre></td></tr></table></figure>

<p>第一行代码设置预估的cell高度，第二行代码修改tableview的rowHeight属性为UITableViewAutomaticDimension。换句话说，就是你让tableview根据其他信息计算cell的尺寸。<br><br><br>如果你现在测试应用，会发现还是不正确的，因为name和address两个控件都设置了SingleLine的属性。所以设置LineNumber为0，使文本行数能够自动根据内容增长。<br><br><br>到这里，就全部完成，再次运行app，tableview的cell就会根据内容自动计算高度了。</p>
<center><img src="/img/self-sizing-cell-demo.png" alt=""></center>]]></content>
    <summary type="html">
    <![CDATA[<p>在iOS8中，Apple为UITableView引入了一种名为Self-Sizing-Cells的新特性。这是新的SDK中最让我兴奋的一种特性。iOS8以前，如果你想要在tableview中显示可变高度的动态内容，必须单独计算每一个cell的高度。现在到了iOS8，Self-Sizing-Cell 提供了显示动态内容的一种解决方案。简言之，使用自适应cell，你只需要做下面几点：<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VIEW加载和显示函数调用顺序]]></title>
    <link href="http://www.ziank.cn/2015/01/20/viewDidLoad/"/>
    <id>http://www.ziank.cn/2015/01/20/viewDidLoad/</id>
    <published>2015-01-20T10:20:32.000Z</published>
    <updated>2015-03-02T06:39:28.000Z</updated>
    <content type="html"><![CDATA[<p>大家没有看错，我要说的就是这个老生常谈的问题，也就是iOS中得ViewController加载和显示view时的函数调用顺序。其实大部分人都知道这些函数的调用顺序，但是，我们还是要再说一下，主要是要强调一下这些函数分别应该实现什么样的功能和注意点。<br><a id="more"></a><br>先说一下顺序吧，免得真有一些人不了解：</p>
<blockquote>
<ul>
<li>initWithNibName: bundle:</li>
<li>viewDidLoad</li>
<li>viewWillAppear:</li>
<li>viewWillLayoutSubViews</li>
<li>viewDidLayoutSubViews</li>
<li>viewDidAppear:</li>
<li>viewWillDisappear:</li>
<li>viewDidDisappear:</li>
<li>dealloc</li>
</ul>
</blockquote>
<p>这些函数就描述了一个view从加载到释放的整个过程。在对应的函数中需要实现和处理的功能应该有如下的考虑。</p>
<h4 id="-initWithNibName:_bundle:">-initWithNibName: bundle:</h4>
<p>该函数是ViewController的初始化函数，必须调用父类的相应初始化方法，而且应该在函数的最开始位置进行调用。调用之前，绝对不可以使用self对象。即使已经调用了父类方法，也不可以在该方法中使用self.view。建议在init方法中直接使用下划线开始的成员对象，不要使用self进行引用。</p>
<h4 id="-viewDidLoad">-viewDidLoad</h4>
<p>该方法在view加载完成之后调用。之所以在init中不能够使用self.view就是因为如果使用，会在init完成之前就调用该方法，可能会导致错误。</p>
<p>viewDidLoad中应该实现的功能是在nib文件中无法实现的界面绘制，以及成员对象的初始化，不应该在该函数中执行耗时的操作（如网络操作）。</p>
<h4 id="-viewWillAppear:">-viewWillAppear:</h4>
<p>该方法在界面出现前调用，可能一个界面会多次出现，那么每次出现之前都会调用该方法。特别是iOS 8推出的右划返回功能，每次将要返回到该界面的时候都会调用该方法，即使没有真正的返回。</p>
<p>该方法中应该实现一些界面显示之前需要做的准备工作，比如需要请求数据，或者某些按钮需要判断是否显示等功能。还有就是一些Notification的监听事件可以在这里添加。</p>
<h4 id="-viewWillLayoutSubViews">-viewWillLayoutSubViews</h4>
<p>该方法不建议重写，因为每次显示都可能调用多次。</p>
<h4 id="-viewDidLayoutSubViews">-viewDidLayoutSubViews</h4>
<p>和viewWillLayoutSubViews一样，每次显示都可能调用多次该方法，所以在该方法中只允许修改subView的位置和大小，尽量不要添加或删除subView。如果一定要添加的话，请注意限制只添加一次。</p>
<h4 id="-viewDidAppear:">-viewDidAppear:</h4>
<p>该方法和viewWillAppear不同，只有当页面完全显示之后才会调用，所以一些界面显示之后需要做的操作建议放在这个方法里，这样可以提高界面切换的效率。放在viewDidLoad和viewWillAppear中都会影响界面的切换效率。</p>
<h4 id="-viewWillDisappear:">-viewWillDisappear:</h4>
<p>建议在这里删除当前界面的Notification监听，避免出现收到notification却执行错误的情况。这个函数实在界面消失之前调用的，所以和viewWillAppear相似，iOS8的右划返回功能滑动时，会调用当前界面的该函数，无论是否真正返回。</p>
<h4 id="-viewDidDisappear:">-viewDidDisappear:</h4>
<p>该方法和viewDidAppear对应，只有当界面完全消失后才会调用，建议在这个函数里可以执行一些界面消失后的内容清空处理。</p>
<h4 id="-dealloc">-dealloc</h4>
<p>针对ARC架构来说，这个函数里不应该执行任何额外的操作。如果使用MRC，需要在该函数里释放对应的成员对象。</p>
<p>主要就说这么一些吧，另外就是界面切换时显示和消失的顺序为：</p>
<p>假设界面A切换到界面B</p>
<blockquote>
<p>A -&gt; viewWillDisappear</p>
<p>B -&gt; viewWillAppear</p>
<p>A -&gt; viewDidDisappear</p>
<p>B -&gt; viewDidAppear</p>
</blockquote>
<p>好了，我了解的也不多，就这么着了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家没有看错，我要说的就是这个老生常谈的问题，也就是iOS中得ViewController加载和显示view时的函数调用顺序。其实大部分人都知道这些函数的调用顺序，但是，我们还是要再说一下，主要是要强调一下这些函数分别应该实现什么样的功能和注意点。<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITABLEVIEW的性能提升]]></title>
    <link href="http://www.ziank.cn/2015/01/20/tableview-improve/"/>
    <id>http://www.ziank.cn/2015/01/20/tableview-improve/</id>
    <published>2015-01-20T10:17:24.000Z</published>
    <updated>2015-03-02T06:39:32.000Z</updated>
    <content type="html"><![CDATA[<p>所谓UITableView的性能，主要指的就是在滑动列表时的流畅度，这个主要是由cell得加载性能决定最终UITableView的滑动效果是否流畅。本文主要介绍两种简单地提升性能的方法：</p>
<blockquote>
<ul>
<li>UITableViewCell的重用机制；</li>
<li>修改滑动过程中的加载机制。<a id="more"></a>

</li>
</ul>
</blockquote>
<h3 id="UITableViewCell的重用机制">UITableViewCell的重用机制</h3>
<p>使用cell的重用机制，需要在申请cell时进行指定，就是说需要使用  initWithStyle:reuseIdentifier:来替代init函数，否则就无法重用申请到的cell内存。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITableViewCell <span class="keyword">*</span>cell = [[UITableViewCellalloc]initWithStyle:UITableViewCellStyleDefaultreuseIdentifier:<span class="comment">@"test”];</span></div></pre></td></tr></table></figure>

<p>这样就申请到了一个可重用的cell，重用标记为test，之所以有一个重用标记是为了能够将类似的cell进行重用，这样很多view都不需要重新绘制，才能够真正的提高性能。</p>
<p>申请到了cell以后，记得在cell的子类中实现方法prepareForReuse，这个方法会在cell滚出屏幕的时候调用，一定要注意该方法必须调用 super的prepareForReuse。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> (void)prepareForReuse</span></div><div class="line">{</div><div class="line">[superprepareForReuse];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>实现了init和perpareForReuse之后，就可以在 UITableViewDataSource的方法 tableView:cellForRowAtIndexPath: 中实现重用cell了。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GroupMessageCell <span class="keyword">*</span>cell = [tableViewdequeueReusableCellWithIdentifier:<span class="comment">@"test”];</span></div></pre></td></tr></table></figure>

<p>使用这个方法可以获取到能够重用的cell，如果没有能够重用的cell，则返回值为nil，这时可以再去进行Cell的内存申请。</p>
<h3 id="修改滑动过程中的加载机制">修改滑动过程中的加载机制</h3>
<p>关于这块，我也没有过多可以详细叙述的，建议大家好好阅读一下Allen的<a href="http://tech.glowing.com/cn/practice-in-uiscrollview/" target="_blank" rel="external">《UIScrollView实践经验》</a>这篇博客，里面详细描述了具体应该怎么利用scrollView的decelerate这个属性来进行性能的提升。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>所谓UITableView的性能，主要指的就是在滑动列表时的流畅度，这个主要是由cell得加载性能决定最终UITableView的滑动效果是否流畅。本文主要介绍两种简单地提升性能的方法：</p>
<blockquote>
<ul>
<li>UITableViewCell的重用机制；</li>
<li>修改滑动过程中的加载机制。]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[成员对象之RETAIN/ASSIGN/COPY/WEAK/STRONG的区分]]></title>
    <link href="http://www.ziank.cn/2015/01/20/retain/"/>
    <id>http://www.ziank.cn/2015/01/20/retain/</id>
    <published>2015-01-20T10:12:43.000Z</published>
    <updated>2015-03-02T06:39:43.000Z</updated>
    <content type="html"><![CDATA[<p>在Object-C中，定义类成员变量或类属性时经常会加上retain之类的声明，这些声明的不同点主要在于哪里呢，本文主要就是讲述他们之间的共同点和区别。</p>
<p>首先，我们知道iOS的对象都是继承于NSObject的，该对象是使用内存应用计数（retainCount）来进行内存管理的。一般情况下，引用计数会在下面的情况发生改变：<br><a id="more"></a></p>
<blockquote>
<ul>
<li>alloc        – 对象分配后引用计数为1</li>
<li>retain       – 对象的引用计数 +1</li>
<li>release      – 对象的引用计数 -1，如果为0着释放对象所占用的内存空间</li>
<li>autorelease  – 对象引用计数-1 如果为0不马上释放，最近一个pool时释放</li>
<li>copy         – copy一个对象变成新的对象(新内存地址) 引用计数为1 原来对象计数不变</li>
</ul>
</blockquote>
<p>下面我们说一下这些修饰关键字对于内存计数造成的影响：</p>
<h4 id="1-_assign、weak">1. assign、weak</h4>
<p>assign不会对引用计数造成任何影响，它相当于直接获取对象的内容进行使用，不进行任何内存的管理；它的set方法就类似于：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// assign</span></div><div class="line">-(<span class="keyword">void</span>)setTestObject :(<span class="keyword">id</span>)newValue{</div><div class="line">testObject= newValue;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>weak是在iOS5中增加的关键字，和assign的作用相同，唯一的不同点是当使用的对象被释放之后，weak修饰的对象值会被设置为nil，而assign的对象会变成野指针，可能导致crash。</p>
<h4 id="2-_retain、strong">2. retain、strong</h4>
<p>对retain修饰的对象进行赋值时会使对象的引用计数+1，就是说如果不存在代码逻辑错误，retain的对象不会被外部直接释放。它的set方法是：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// retain</span></div><div class="line">-(<span class="keyword">void</span>)setTestObject :(<span class="keyword">id</span>)newValue{</div><div class="line"><span class="keyword">if</span> (testObject != newValue) {</div><div class="line">[testObject release];</div><div class="line">testObject= [newValue retain];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从代码可以看出，retain对象赋值时会释放旧对象（testObject），将输入对象（newValue）的值赋给成员对象（testObject），然后将输入对象（newValue）的引用计数+1.</p>
<p>strong和weak一样都是iOS5中增加的关键字，作用和retain完全一样。</p>
<h4 id="3-_copy">3. copy</h4>
<p>copy和assign、retain不同，它不对旧的对象进行任何处理，但是会新建一个索引计数为1的对象，然后释放旧对象。它的set方法如下：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// copy</span></div><div class="line">-(<span class="keyword">void</span>)setTestObject :(<span class="keyword">id</span>)newValue{</div><div class="line"><span class="keyword">if</span> (testObject != newValue) {</div><div class="line">[testObject release];</div><div class="line">testObject = [newValue <span class="keyword">copy</span>];</div><div class="line">}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Copy其实是建立了一个相同的新对象，它和原对象在内存中得地址是不相同的。而retain的对象只是引用计数+1，实际对象在内存中的地址和原对象还是一样的。<br><br><br>综上所述，assign和weak适用于一些不需要管理内存的成员属性；而retain和strong则适用于一些生命周期有限制的成员属性，使用retain和strong可以避免对象被提前释放；copy则适用于需要完全独自拥有的成员属性，使用copy建立新的对象防止被外部修改。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Object-C中，定义类成员变量或类属性时经常会加上retain之类的声明，这些声明的不同点主要在于哪里呢，本文主要就是讲述他们之间的共同点和区别。</p>
<p>首先，我们知道iOS的对象都是继承于NSObject的，该对象是使用内存应用计数（retainCount）来进行内存管理的。一般情况下，引用计数会在下面的情况发生改变：<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[正确使用BLOCK避免CYCLE RETAIN和CRASH]]></title>
    <link href="http://www.ziank.cn/2015/01/20/block/"/>
    <id>http://www.ziank.cn/2015/01/20/block/</id>
    <published>2015-01-20T09:30:50.000Z</published>
    <updated>2015-03-02T06:39:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block的简介">Block的简介</h2>
<p>Block是Object-C中的一个对象，类似于C语言中的函数指针。与函数指针不同的时Block可以使用上下文中的变量，而函数指针只可以使用全局的变量和入参。</p>
<h2 id="Block的使用语法">Block的使用语法</h2>
<p>Block可以命名，也可以直接使用未命名的Block对象，如下面示例，就是直接返回了一个未命名的Block对象：<br><a id="more"></a></p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">long</span> (^)(<span class="keyword">int</span>, <span class="keyword">int</span>)) sumBlock {</div><div class="line"><span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">100</span>;</div><div class="line"><span class="keyword">return</span> [[ ^ <span class="keyword">long</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">base</span> + a + b;</div><div class="line">} copy] autorelease];</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br><br>下面一个例子则是先声明了一种Block对象的类型，再定义对应的Block对象：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef <span class="keyword">long</span> (^BlkSum)(<span class="keyword">int</span>, <span class="keyword">int</span>);</div><div class="line"></div><div class="line">- (BlkSum) sumBlock {</div><div class="line"><span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">100</span>;</div><div class="line">BlkSum blk = ^ <span class="keyword">long</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">base</span> + a + b;</div><div class="line">}</div><div class="line"><span class="keyword">return</span> [[blk copy] autorelease];</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Block中得变量使用">Block中得变量使用</h2>
<p>Block中的变量主要是指上下文中得assign/retain/weak等类型的局部变量或成员变量的使用：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">100</span>;</div><div class="line"><span class="keyword">base</span> += <span class="number">100</span>;</div><div class="line">BlkSum sum = ^ <span class="keyword">long</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">base</span> + a + b;</div><div class="line">};</div><div class="line"><span class="keyword">base</span>++;</div><div class="line">printf(<span class="string">"%ld"</span>,sum(<span class="number">1</span>,<span class="number">2</span>));</div></pre></td></tr></table></figure>

<p>如上面示例中的使用，就是使用了默认assign类型的局部变量base，结果就等于203。因为Block对象在定义时对上下文中的变量进行了备份，所以base在执行Block时的值为200，输出就是203。因此，在Block的内部不能够对assign类型的变量进行修改，因为修改的时备份的值，对实际变量的值是修改无效的。<br><br><br>下面在定义base的时候加上__block，则返回的值为204。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> <span class="keyword">base</span> = <span class="number">100</span>;</div><div class="line"><span class="keyword">base</span> += <span class="number">100</span>;</div><div class="line">BlkSum sum = ^ <span class="keyword">long</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) {</div><div class="line"><span class="keyword">return</span> <span class="keyword">base</span> + a + b;</div><div class="line">};</div><div class="line"><span class="keyword">base</span>++;</div><div class="line">printf(<span class="string">"%ld"</span>,sum(<span class="number">1</span>,<span class="number">2</span>));</div></pre></td></tr></table></figure>

<p><br><br>原因就是使用<strong>block/</strong>weak定义的变量，Block在定义的时候并没有进行数值的备份，而是记录了类似于指针的地址，所以在后面执行Block的时候，用的值并不是定义时候获取的备份，而是该变量的实际数值。也因此，可以在Block内部对<strong>block/</strong>weak修饰的变量进行修改。</p>
<h2 id="retain_cycle（引用嵌套）">retain cycle（引用嵌套）</h2>
<p>retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了孤岛，谁也释放不了谁。<br><br><br>举个简单地例子：</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ASIHTTPRequest *<span class="built_in">request</span> = [ASIHTTPRequest requestWithURL:url];</div><div class="line">[<span class="built_in">request</span> setCompletionBlock:^{</div><div class="line">NSString* <span class="built_in">string</span> = [<span class="built_in">request</span> responseString];</div><div class="line">}];</div></pre></td></tr></table></figure>

<p>由于request和Block对象相互之间有强引用的关系，导致最后两者都无法释放。也就是Block对象释放必须先释放request，而request释放又必须先释放Block对象，最后都无法释放。<br><br><br>解决的办法就是在Block对象中对request进行弱引用，这样Block的释放就不依赖于request的释放，最后能够全部释放。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block ASIHTTPRequest *<span class="built_in">request</span> = [ASIHTTPRequest requestWithURL:url];</div><div class="line">[<span class="built_in">request</span> setCompletionBlock:^{</div><div class="line">NSString* <span class="built_in">string</span> = [<span class="built_in">request</span> responseString];</div><div class="line">}];</div></pre></td></tr></table></figure>

<h2 id="Block使用对象被提前释放">Block使用对象被提前释放</h2>
<p>Block使用对象被提前释放主要是由于开发者担心retain cycle错误的使用__block导致。</p>
<figure class="highlight Object-C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MyClass.m</span></div><div class="line">- (<span class="keyword">void</span>) test {</div><div class="line">__block MyClass* weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">double</span> delayInSeconds = <span class="number">10.0</span>;</div><div class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));</div><div class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>){</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf);</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// other.m</span></div><div class="line">MyClass* obj = [[[MyClass alloc] init] autorelease];</div><div class="line">[obj test];</div></pre></td></tr></table></figure>

<p>这里用dispatch_after模拟了一个异步任务，10秒后执行Block。但执行Block的时候MyClass* obj已经被释放了，导致crash。解决办法是不要使用__block。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Block的简介">Block的简介</h2>
<p>Block是Object-C中的一个对象，类似于C语言中的函数指针。与函数指针不同的时Block可以使用上下文中的变量，而函数指针只可以使用全局的变量和入参。</p>
<h2 id="Block的使用语法">Block的使用语法</h2>
<p>Block可以命名，也可以直接使用未命名的Block对象，如下面示例，就是直接返回了一个未命名的Block对象：<br>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.ziank.cn/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.ziank.cn/categories/iOS/"/>
    
  </entry>
  
</feed>
